# distobject-go

[![Build Status](https://github.com/didip/distobject-go/actions/workflows/test.yml/badge.svg)](https://github.com/didip/distobject-go/actions/workflows/test.yml)
[![Go Version](https://img.shields.io/badge/go-1.22-blue)](https://golang.org/dl/)
[![License: MIT](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)

![distobject](https://github.com/user-attachments/assets/3b7b53fa-879f-40b5-9412-cf360fca57a5)

Also see: https://github.com/didip/distobject-py

Distributed Object Library for Go (with Redis backend)

âœ… Automatic dirty tracking  
âœ… Save only changed fields  
âœ… Load objects from Redis  
âœ… Pub/Sub notifications on object updates  
âœ… Concurrency safe  
âœ… ULID based IDs

---

## Project Status

> This project is **totally WIP**.

All source code was **generated by AI (ChatGPT)**,  
with **project ideas, design direction, and corrections provided by me**.

It serves as a demonstration of **how far AI can assist in building real, usable software** under human guidance with very minimal interference.

---

## âœ¨ Features

- Atomic partial updates via Redis `HSET`
- Auto-generate IDs using ULID
- Redis Pub/Sub notifications on field changes
- Reflective dirty tracking
- Concurrency safe for goroutines
- Easy integration into any Go project

---

## ðŸš€ Quick Start

```go
import (
    "github.com/didip/distobject-go/distobject"
    "time"
    "fmt"
)

type User struct {
    Name  string `redis:"name"`
    Email string `redis:"email"`
}

func main() {
    r := distobject.NewRedisClient("localhost:6379")

    user1 := &User{Name: "Alice", Email: "alice@example.com"}
    user2 := &User{Name: "Bob", Email: "bob@example.com"}

    d := distobject.NewDistObject(r, "user", "user-updates")
    
    _ = d.Save(user1)
    id1 := d.ID()

    d2 := distobject.NewDistObject(r, "user", "user-updates")
    _ = d2.Save(user2)
    id2 := d2.ID()

    // Start listener for all objects
    _ = d.StartListener()

    // Register both objects
    d.AddObject(id1, user1)
    d.AddObject(id2, user2)

    // Simulate external updates
    go func() {
        time.Sleep(2 * time.Second)
        updater := &User{}
        updaterDist := distobject.NewDistObject(r, "user", "user-updates")
        _ = updaterDist.Load(id1, updater)
        updater.Email = "newalice@example.com"
        updaterDist.MarkChanged("email")
        _ = updaterDist.Save(updater)
    }()

    go func() {
        time.Sleep(3 * time.Second)
        updater := &User{}
        updaterDist := distobject.NewDistObject(r, "user", "user-updates")
        _ = updaterDist.Load(id2, updater)
        updater.Name = "Robert"
        updaterDist.MarkChanged("name")
        _ = updaterDist.Save(updater)
    }()

    time.Sleep(5 * time.Second)

    fmt.Println("Updated user1:", user1.Name, user1.Email)  // Alice newalice@example.com
    fmt.Println("Updated user2:", user2.Name, user2.Email)  // Robert bob@example.com
}
```

## Running Tests Locally

```bash
docker compose up --build --abort-on-container-exit --exit-code-from test-runner
```
